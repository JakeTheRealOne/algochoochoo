\documentclass[twocolumn, utf8]{article}
\usepackage{graphicx}
\usepackage[a4paper, margin=2cm]{geometry}
\setlength{\columnsep}{1cm}
\usepackage{lipsum}
\usepackage{hyperref}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}
\usetikzlibrary{calc}
\usetikzlibrary{fit}
\usetikzlibrary{trees, shapes.geometric, patterns}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{fancyvrb}
\usepackage{listingsutf8}
\usepackage{url}
\usepackage{etoolbox}
\usepackage{titlesec}
\usepackage{svg}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{svg}
\usepackage{float}
\usepackage{fancyvrb}

\usepackage[utf8]{inputenc}
\usepackage{pmboxdraw}
\usepackage{newunicodechar}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{verbatim}
\usepackage{tabularx}
\usepackage{fvextra}

\newunicodechar{─}{\texttt{─}}
\newunicodechar{│}{\texttt{│}}
\newunicodechar{┌}{\texttt{┌}}
\newunicodechar{┐}{\texttt{┐}}
\newunicodechar{└}{\texttt{└}}
\newunicodechar{┘}{\texttt{┘}}
\newunicodechar{├}{\texttt{├}}
\newunicodechar{┤}{\texttt{┤}}

\lstset{
    language=Java,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{gray},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    showstringspaces=false,
    tabsize=4,
    breaklines=true,
    frame=single,
    captionpos=b,
    inputencoding=utf8,
    extendedchars=true,
    literate={é}{{\'e}}1 {ê}{{\^e}}1 {û}{{\^u}}1 {è}{{\`e}}1 {à}{{\`a}}1 {ç}{{\c{c}}}1
}

\theoremstyle{definition}
\newtheorem{definition}{Définition}

\theoremstyle{lemma}
\newtheorem{lemma}{Lemme}

\setlength{\parindent}{0pt}
\pagestyle{fancy}
\lhead{Réseaux de transport: Algorithmes et Structures de données}
\rhead{\thepage}
\cfoot{}
\bibliographystyle{plain}
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\arraystretch}{1.5}
\renewcommand{\refname}{Références}
\renewcommand{\algorithmcfname}{Algorithme}

\tikzset{
  root/.style = {circle, draw, text=black, font=\bfseries, minimum width=1cm, minimum height=1cm},
  % level2/.style = {rectangle, draw, fill=blue!50, text=white, minimum width=0.5cm, minimum height=0.5cm},
level2/.style = {rectangle, draw, pattern=north east lines, pattern color=blue!50, minimum width=0.5cm, minimum height=0.5cm},
level3/.style = {rectangle, draw, pattern=north east lines, pattern color=red!50, minimum width=0.5cm, minimum height=0.5cm},
  % level3/.style = {rectangle, draw, fill=red!50, text=white, minimum width=0.5cm, minimum height=0.5cm},
  level4/.style = {circle, draw, fill=black, inner sep=0pt, minimum size=1.6pt, font=\tiny, text=white}
}

\title{Réseaux de transport: Algorithmes et Structures de données\newline \newline \large Rapport}
\author{Bilal Vandenberge}
\date{Mai 2025}

\begin{document}

\setmonofont{Source Code Pro}[Renderer=Basic]
\setmainfont{Source Code Pro}[Renderer=Basic]

\maketitle

\section{Introduction}

Ce rapport sert de point d'entrée pour le projet du cours Algorithmique 2 de l'Université libre de Bruxelles pour l'année académique 2024-2025. Il a été demandé de livrer un programme Java dont le but et de convertir des données stockées dans des fichiers sous le format GTFS en une ou plusieurs structures de données permettant la recherche du chemin optimal selon certains critères. Les aspects important de l'algorithme sont l'optimalité et la validité de celui-ci.

\subsection*{Définition du problème}

Soient les entrées suivantes:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item Des données GTFS représentant des réseaux de transports publiques.
    \item Le nom d'une gare source que nous appellerons $s$ tout au long de ce rapport.
    \item Le nom d'une gare cible que nous appellerons $t$ tout au long de ce rapport.
    \item Une heure de départ que nous appellerons $h$ tout au long de ce rapport.
\end{itemize}

Sous les conditions suivantes:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item Les données GTFS sont stockées dans un ensemble de fichiers sous contraintes détaillées dans la sous-section \hyperref[gtfs-contraintes]{ci-dessous}.
    \item $s$ correspond au nom d'au moins une gare.
    \item $t$ correspond au nom d'au moins une gare.
    \item $h$ est compris entre {00$:$00$:$00 et 99$:$99$:$99}. Ce choix est expliqué \hyperref[why-999]{plus bas} dans ce rapport.
\end{itemize}

L'algorithme doit retourner un chemin valide partant à \texttt{h} de \texttt{s} à \texttt{t} qui est considéré optimal selon certains critères. Le critère par défaut est la durée totale du chemin (que nous chercherons à minimiser).
\begin{definition}[Chemin]
Un \textbf{chemin} est une suite de connexions et/ou de transferts.
\end{definition}
\begin{definition}[Connexion]
Une \textbf{connexion} est le mouvement d'un transport d'une gare à une autre caractérisée par une heure de départ et une durée.
\end{definition}
\begin{definition}[Transfert]
Un \textbf{transfert} est le mouvement à pied entre deux gares proches caractérisé par une durée et sans contrainte de départ (la personne peut partir à l'heure qu'elle veut).
\end{definition}
\begin{definition}[Temps d'attente]
    Le \textbf{temps d'attente} $W_{(v, e)}$ d'un arc $e$ après un n\oe ud $v$ (donc $e$.from = $v$)  est la durée qui sépare l'heure d'arrivée à $v$ et l'heure de départ avec le transport de $e$ depuis $v$. Si $arr$ représente l'heure d'arrivée à $v$ et $dep$ représente l'heure de départ de $e$:
    \[
    W_{(v, e)} = 
    \begin{cases}
        (dep - arr) \% \texttt{24:00:00} & \tiny \text{si e est une connexion}\\
        0 & \tiny \text{si e est un transfert}
    \end{cases}
    \]
    où $\%$ est le modulo euclidien \cite{10.1145/128861.128862}.
\end{definition}

Cette définition est délicate: pourquoi effectuons nous un modulo sur la différence entre le départ et l'arrivée ? Cela nous permet de nous débarrasser de deux problèmes. Sachant que les données GTFS sont périodiques (c'est-à-dire elles se répètent jour après jour):

\begin{enumerate}[leftmargin=1.5em, itemsep=0.5em]
    \item Un temps d'attente ne peut être négatif: l'utilisateur peut attendre le jour suivant pour prendre le transport de $e$. Par exemple, si l'utilisateur manque le dernier métro à 23$:$00$:$00, et que le premier métro le lendemain est à 05$:$30$:$00, le temps d'attente n'est pas de -17 heures et 30 minutes (illégal) mais de 6 heures et 30 minutes.
    \item Un temps d'attente supérieur à 24$:$00$:$00 peut être réduit. Pour rappel nous autorisons des heures dans les fichiers GTFS et pour $h$ jusque 99$:$99$:$99. Par exemple, 28$:$00$:$00 est 02$:$00$:$00 du lendemain. Ainsi, vu que les données GTFS sont périodiques, l'attente jusque 28$:$00$:$00 peut être réduit, avec un modulo, à l'attente jusque 02$:$00$:$00.
\end{enumerate}

\begin{definition}[Validité d'un chemin]
Formellement, un chemin $P$ est dit \textbf{valide} si pour deux arcs consécutifs de $P$, $e$ de la gare $u$ à la gare $v$ et $j$ de la gare $k$ à la gare $l$, $v$ la gare d'arrivée de $e$ est identique à $k$ la gare de départ de $j$ et le temps d'attente $W_{(v, j)}$ est positif. La définition du temps d'attente ci-dessus indique que celui-ci sera toujours positif, nous pouvons résumer la définition à:

Un chemin $P$ est dit \textbf{valide}, si pour toute paire d'arcs consécutifs dans $P$, la gare d'arrivée du premier arc est identique à la gare de départ du second.
\end{definition}

\subsection*{Format des fichiers GTFS}
\label{gtfs-contraintes}

Le format utilisé par le programme est une version allegée de la General Transit Feed Specification \cite{gtfs}.

Les fichiers GTFS doivent être stockés dans un dossier composé d'un sous-dossier pour chaque agence. Eux-même doivent être composés de 5 fichiers: \texttt{routes.csv}, \texttt{trips.csv}, \texttt{stops.csv}, \texttt{stop\_times.csv}.

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item \texttt{routes.csv} contient les informations de chaque ligne (nom et type de transport).
    \item \texttt{trips.csv} liste tous les trajets pour chaque ligne.
    \item \texttt{stops.csv} contient les informations de chaque gare (nom et position géographique).
    \item \texttt{stop\_times.csv} range le contenu des trajets, c'est-à-dire la séquence de gares visitées par le transport pour chaque trajet.
\end{itemize}

La figure \ref{fig:gtfs-tree} représente un exemple avec l'arbre du dossier contenant les données des grandes agences de transport public belges. 

\begin{figure}[h]
    \centering
    \begin{Verbatim}[fontsize=\small, commandchars=\\\{\}]
    GTFS
    ├── DELIJN
    │   ├── routes.csv
    │   ├── stops.csv
    │   ├── stop_times.csv
    │   └── trips.csv
    ├── SNCB
    │   ├── routes.csv
    │   ├── stops.csv
    │   ├── stop_times.csv
    │   └── trips.csv
    ├── STIB
    │   ├── routes.csv
    │   ├── stops.csv
    │   ├── stop_times.csv
    │   └── trips.csv
    └── TEC
        ├── routes.csv
        ├── stops.csv
        ├── stop_times.csv
        └── trips.csv
    \end{Verbatim}
    \caption{Exemple de structure d'un dossier GTFS valide}
    \label{fig:gtfs-tree}
\end{figure}

\subsubsection*{routes.csv}

Un fichier \texttt{routes.csv} est composé des colonnes (route\_id, route\_short\_name, route\_long\_name, route\_type).

\begin{figure}[h]
    \scriptsize
    \centering
    \begin{tabular}{cccc}
    \hline
    \tiny route\_id & \tiny route\_short\_name & \tiny route\_long\_name & \tiny route\_type \\
    \hline
    SNCF-1 & IC & LYON - PARIS NORD & TRAIN \\
    SNCF-2 & L & MODANE - TORINO & TRAIN \\
    STIB-12 & 19 & SIMONIS - DE WAND & TRAM \\
    ... & ... & ... & ... \\
    \hline
    \end{tabular}
    \caption{Exemple d'un fichier \texttt{routes.csv}}
    \label{fig:routes-csv}
\end{figure}

\subsubsection*{trips.csv}

Un fichier \texttt{trips.csv} est composé des colonnes (trip\_id, route\_id). Chaque ligne peut avoir plusieurs trajets prenant place à des heures différentes dans la journée.

\begin{figure}[h]
    \scriptsize
    \centering
    \begin{tabular}{cc}
    \hline
    \tiny trip\_id & \tiny route\_id \\
    \hline
    SNCF-2500\_2--250025F\_0 & SNCF-128 \\
    SNCF-2500\_2--250025F\_1 & SNCF-128 \\
    STIB-125400536291553002 & STIB-12 \\
    ... & ... \\
    \hline
    \end{tabular}
    \caption{Exemple d'un fichier \texttt{trips.csv}}
    \label{fig:trips-csv}
\end{figure}


\subsubsection*{stops.csv}

Un fichier \texttt{stops.csv} est composé des colonnes (stop\_id, stop\_name, stop\_lat, stop\_lon). Les deux dernières représentent la latitude et longitude de la gare. Comme dit précedement, \texttt{s} et \texttt{t} doivent référer à une gare et donc correspondre à au moins une entrée \texttt{stop\_name}.

\begin{figure}[h]
    \scriptsize
    \centering
    \begin{tabular}{cccc}
    \hline
    \tiny stop\_id & \tiny stop\_name & \tiny stop\_lat & \tiny stop\_lon \\
    \hline
    SNCF-S05 & Paris Nord & 48.880619 & 2.355638 \\
    SNCF-S08 & Phare des baleines & 46.2431 & -1.558861 \\
    STIB-8711 & AUMALE & 50.839462 & 4.312081 \\
    ... & ... & ... & ... \\
    \hline
    \end{tabular}
    \caption{Exemple d'un fichier \texttt{stops.csv}}
    \label{fig:stops-csv}
\end{figure}

\subsubsection*{stop\_times.csv}
\label{why-999}

Un fichier \texttt{stop\_times.csv} est composé des colonnes (trip\_id, departure\_time, stop\_id, stop\_sequence). L'heure de départ (\texttt{departure\_time}) est représentée sous le format HH$:$MM$:$SS. Une heure n'est pas bornée à 24$:$00$:$00 car dans le cas où un trajet débute tard dans la soirée (23h50 par exemple), il doit pouvoir continuer jusqu'au petit matin. Nous placerons une limite à 99$:$99$:$99 pour éviter des erreurs d'overflow dans l'implémentation et garder un affichage propre dans les réponses du programme. 

La position (\texttt{stop\_sequence}) précise la position de la gare dans le trajet tel que le transport passe par chaque gare dans un ordre croissant des positions. Il est important de noter que le format n'oblige pas le fichier à être ordonné par positions et les trajets à être contigu (que chaque position de 1 à n, le nombre de gares du trajet, apparaisse une et une seule fois) mais il doit exister au plus une gare dans le trajet pour chaque position.

\begin{figure}[h]
    \scriptsize
    \centering
    \begin{tabular}{cccc}
    \hline
    \tiny trip\_id & \tiny departure\_time & \tiny stop\_id & \tiny stop\_sequence \\
    \hline
    SNCF-2500\_2--250025F\_0 & 08$:$00$:$00 & SNCF-S13 & 1 \\
    SNCF-2500\_2--250025F\_0 & 08$:$34$:$00 & SNCF-S88 & 2 \\
    SNCF-2500\_2--250025F\_0 & 09$:$10$:$00 & SNCF-S08 & 4 \\
    ... & ... & ... & ... \\
    \hline
    \end{tabular}
    \caption{Exemple d'un fichier \texttt{stop\_times.csv}}
    \label{fig:stoptimes-csv}
\end{figure}

\subsection*{Exemple du problème}
\label{toc}

Afin d'éclaircir les différents algorithmes et structures de données abordés dans ce rapport, nous utiliserons tout au long un exemple simple et bref afin d'y appliquer les concepts. Dans celui-ci, nous tentons de nous déplacer de Québec à Montréal dès 8h45 du matin dans le réseau ferroviaire fictif du Canada, la TOC (\texttt{Transport of Canada}) (voir figure \ref{fig:toc_gtfs}). Les données GTFS de cet exemple se trouve dans le dossier \texttt{src/test/resources/GTFS}. Nous posons donc: 

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item $s$ = "Québec"
    \item $t$ = "Montréal"
    \item $h$ = 08$:$45$:$00
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{toc_ex.png}
    \caption{Réseau ferroviaire de la TOC}
    \label{fig:toc_gtfs}
\end{figure}


\section{Solution}

Le problème que nous souhaitons résoudre est connus sous le nom de Time-Dependent Shortest Path, donc la recherche d'un chemin qui minimise un ou des critères dans un graphe aux arcs dont le poids varie en fonction du temps. L'algorithme que nous utilisons pour le résoudre est une variante de l'algorithme de Dijkstra \cite{dijkstra1959note, cardinal2025} connu sous le nom de TD Dijkstra (Dijkstra dépendant du temps ou Time-Dependent Dijkstra).

\subsection*{Structures de données utilisées}

\subsubsection*{Représentation du graphe}
\label{graph_def}

Nous travaillons avec une adaptation simplifiée d'un graphe dépendant du temps (ou time-dependent graph en anglais) \cite{wang2019time}. Le graphe $G$($V$, $A$, $T$) est composé de trois ensembles:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item $V$ l'ensemble des n\oe uds, des gares
    \item $A$ l'ensemble des arcs de connexion
    \item $T$ l'ensemble des arcs de transfert
\end{itemize}

Nous implémentons ce graphe à l'aide d'une liste d'adjacence. Donc chaque n\oe ud gardera une liste des connexions et transferts sortant de celui-ci. Ce graphe compte comme propriétés:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item Le graphe $G$ est un multigraphe non-FIFO \cite{Delling2009}.
    \item Les arcs de connexions ont des poids positifs dépendants du temps (= un temps d'attente + une durée).
    \item Les arcs de transferts ont des poids positifs constants dans le temps (= une durée).
\end{itemize}

La figure \ref{fig:toc-graph} représente le graphe dépendant du temps de l'exemple de la TOC (les noms des gares ont été remplacées par leur initiales: Québec $\rightarrow$ Q etc.). Elle montre que pour cet exemple, il y a en tout 10 n\oe uds, 16 arcs de connexion et 4 arcs de transferts. Les arcs de connexion ont été déterminés à partir du contenu de \texttt{src/test/resources/GTFS/TOC/stop\_times.csv}. L'évaluation des arcs de transfert est expliquée dans la sous-section ci-dessous.

\begin{figure}
    \centering
    \begin{tikzpicture}[>=stealth, auto]
      \node[rectangle, draw, fill=red!20] (Q) at (0,1) {Q};
      \node[rectangle, draw, fill=blue!20] (TS) at (3,2) {TS};
      \node[rectangle, draw, fill=red!20] (TN) at (2,3) {TN};
      \node[rectangle, draw, fill=magenta!20] (ON) at (3,0) {ON};
      \node[rectangle, draw, fill=red!20] (OS) at (2,-1) {OS};
      \node[rectangle, draw, fill=blue!20] (C) at (4.5,2) {C};
      \node[rectangle, draw, fill=blue!20] (V) at (6,2) {V};
      \node[rectangle, draw] (M) at (8,1) {M};
      \begin{scope}
         \fill[blue!20] (M.south west) rectangle ($(M.north west)!0.5!(M.north east)$);
         \fill[magenta!20] ($(M.south west)!0.5!(M.south east)$) rectangle (M.north east);
      \end{scope}
      \node[rectangle, draw, align=center] at (M.center) {M};
      \node[rectangle, draw, fill=magenta!20] (TR) at (4.5,0) {TR};
      \node[rectangle, draw, fill=magenta!20] (H) at (6,0) {H};
      \path[->, thick]
        (Q) edge[bend left] node[left] {\tiny 10min} (TN);
      \path[->, thick]
        (TN) edge[bend left] node[left] {\tiny 20min} (Q);
      \path[->, thick]
        (Q) edge[bend right] node[left] {\tiny 25min} (OS);
      \path[->, thick]
        (OS) edge[bend right] node[left] {\tiny 10min} (Q);
      \path[->, thick]
        (ON) edge[bend left] node[above] {\tiny 5min} (TR);
      \path[->, thick]
        (ON) edge[bend right] node[below] {\tiny 1min} (TR);
      \path[->, thick]
        (TR) edge[bend left] node[above] {\tiny 35min} (H);
      \path[->, thick]
        (TR) edge[bend right] node[below] {\tiny 1min} (H);
      \path[->, thick]
        (H) edge[bend left] node[left] {\tiny 45min} (M);
      \path[->, thick]
        (H) edge[bend right] node[below] {\tiny 1min} (M);
      \path[->, thick]
        (V) edge[bend left] node[left] {\tiny 60min} (M);
      \path[->, thick]
        (V) edge[bend right] node[left] {\tiny 60min} (M);
      \path[->, thick]
        (C) edge[bend left] node[above] {\tiny 60min} (V);
      \path[->, thick]
        (C) edge[bend right] node[below] {\tiny 60min} (V);

      \path[->, thick]
        (TS) edge[bend left] node[above] {\tiny 60min} (C);
      \path[->, thick]
        (TS) edge[bend right] node[below] {\tiny 60min} (C);

      \path[->, thick, dashed]
        (TS) edge[bend right] node[right] {\tiny 6.8min} (TN);

      \path[->, thick, dashed]
        (TN) edge[bend right] node[below] {\tiny 6.8min} (TS);

     \path[->, thick, dashed]
        (OS) edge[bend right] node[right] {\tiny 2min} (ON);

      \path[->, thick, dashed]
        (ON) edge[bend right] node[right] {\tiny 2min} (OS);
      \begin{scope}[shift={(4,-0.7)}]
        % Fond de la boîte de légende
        \fill[white] (0,0) rectangle (2.7,-0.8);
        \draw (0,0) rectangle (2.7,-0.8);
    
        % Exemple de ligne pleine
        \draw[->, thick] (0.2,-0.2) -- (0.8,-0.2) node[right,black] {Connexion};
    
        % Exemple de ligne pointillée
        \draw[->, thick, dashed] (0.2,-0.6) -- (0.8,-0.6) node[right,black] {Transfert};
      \end{scope}
    \end{tikzpicture}
    \caption{Graphe de la TOC}
    \label{fig:toc-graph}
\end{figure}

\subsubsection*{Transferts à pied}

Il doit être possible pour un utilisateur de changer de gares (Notons que sans cela, l'utilisateur ne pourrait pas changer de réseau: Dans l'exemple belge, un utilisateur commençant à une gare \texttt{SNCB} ne pourra jamais accéder à une gare \texttt{STIB} ou \texttt{De Lijn} ou \texttt{TEC}).
Premièrement, il est fondamental de définir un critère de proximité entre deux gares. Si aucune limite n'était fixée, nous devrions stocker et prendre en compte pour chaque gare la distance avec le reste des gares du graphe (nous voulons éviter des comportements quadratiques comme celui-ci). Nous définissons donc:

\begin{definition}[Critère de proximité]
    Le \textbf{critère de proximité} est la distance $x$ (en mètres) tel que pour tout transfert représenté dans le graphe, la distance à vol d'oiseau entre les deux gares n'excède pas $x$:
    \[
    \forall (u, v) \in T, \quad \texttt{dist}(u, v) \leq x
    \]
\end{definition}

où \texttt{dist}$(u, v)$ est la distance géographique entre $u$ et $v$.

\begin{definition}[Distance géographique]
La \textbf{distance} $d_{(u, v)}$ entre deux points géographiques $u$ et $v$ sur le globe terrestre:

\begingroup
\[
\resizebox{0.9\linewidth}{!}{$
d_{(u, v)} = 2R \cdot \arcsin\left(\sqrt{\sin^2\left(\frac{v_{lat} - u_{lat}}{2}\right) + \cos(u_{lat}) \cdot \cos(v_{lat}) \cdot \sin^2\left(\frac{v_{long} - u_{long}}{2}\right)}\right)
$}
\]
\endgroup
où $R$ est le rayon de la Terre (environ 6371 km), $u_{lat}, v_{lat}$ sont les latitudes (en radians) et $u_{lon}, v_{lon}$ sont les longitudes (en radians). Cette définition découle de la formule de haversine \cite{Karney2013, veness2011}.
\end{definition}


Pour l'exemple de la \hyperref[toc]{TOC} avec un critère de proximité $x = 500$, $T$ est composé de 4 arcs:
\newline
\newline
$T$ = \{\\
    \texttt{("Toronto Nord", "Toronto Sud")},\\
    \texttt{("Toronto Sud", "Toronto Nord")},\\
    \texttt{("Ottawa Nord", "Ottawa Sud")},\\
    \texttt{("Ottawa Sud", "Ottawa Nord")}\\
    \}
\newline
\newline
car les gares Toronto Nord et Toronto Sud sont séparés par une distance de 400 mètres et Ottawa Nord et Ottawa Sud par 50 mètres (données géographiques de \texttt{src/test/resources/GTFS/TOC/stops.csv}).
\newline
\newline
Le choix de $x$ est cruciale: $x$ est directement proportionnel à la taille de $T$ (complexités temporelles et spatiales impliquées) comme le montre la figure \ref{fig:x_anal} analysant le nombre de transferts par rapport au critère de proximité sur les 60.000 gares des données GTFS belges, un très grand graphe. Un $x$ trop grand tuera la mémoire et le temps du programme tandis qu'un $x$ trop petit éliminera des meilleurs chemins qui ont des chemins à pied plus grand que $x$. Nous avons choisi le compromis $x = 500m$ comme valeur par défaut du programme mais l'utilisateur est libre de la redéfinir (voir \texttt{README}).

\begin{figure}[H]
    \centering
    \includesvg[width=\linewidth]{t_anal.svg}
    \caption{Analyse de la taille de $T$ en fonction de $x$ sur les gares belges}
    \label{fig:x_anal}
\end{figure}

Maintenant pour construire $T$ plusieurs choix de modélisation s'offrent à nous.

\vspace{2pt}
\textbf{Approche naïve}
\vspace{2pt}

La première approche qui vient à l'esprit est d'itérer sur toutes les paires possibles de gares et d'ajouter un arc de transfert dont le poids correspond au temps de marche, en prenant en compte le critère de proximité.

\begin{algorithm}
\caption{Évaluation des transferts à pied par force brute}
\label{algo:footbf}
\KwIn{$V$ : ensemble de gares, $x$ : critère de proximité}
\KwOut{$T$ : ensemble des transferts respectant le critère de proximité}

$T$ $\gets \emptyset$\;

\ForEach{$u$ $\in$ $V$}{
    \ForEach{$v$ $\in$ $V$}{
        \If{$u$ = $v$ \textbf{or} dist($u$, $v$) > $x$}{
            \textbf{continue}
        }
        $weight$ $\gets$ walktime($u$, $v$)\;
        $T$.add(Edge($u$, $v$, $weight$))\;
    }
}
\Return $T$\;
\end{algorithm}

L'algorithme \ref{algo:footbf} présente cette approche. La complexité temporelle de celle-ci est en $O(|V|^{2})$. Nous éviterons donc de l'emprunter.

\vspace{2pt}
\textbf{Approche avancée}
\vspace{2pt}

L'approche avancée utilise un un arbre STR qui permet la recherche de gares à proximité en temps logarithmique amortie. Un arbre STR (ou STR tree) est un arbre T \cite{LehmanC86} qui indexe les gares spatialement en utilisant l'algorithme Sort-Tile-Recursive \cite{inproceedings97} pour packer l'arbre (voir annexe \ref{annexe:A}). Si nous fixons le nombre de gares par n\oe ud de l'arbre à 10, cette structure de donnée offre les opérations:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item Construction en $O(|V|log_{10}|V|)$
    \item Recherche des voisins dans un rayon de $x$ mètres en moyenne en $O(log_{10}|V] + \bar{t}_{x})$ et dans le pire des cas en $O(|V|)$
\end{itemize}

avec $\bar{t}_{x}$ le nombre moyen de gares dans un rayon de $x$ mètres autour d'une gare donnée (ce paramètre est directement proportionnel à $x$).

\begin{algorithm}
\caption{Évaluation des transferts à pied à l'aide d'un arbre STR}
\label{algo:footbt}
\KwIn{$V$ : ensemble de gares, $x$ : critère de proximité}
\KwOut{$T$ : ensemble des transferts respectant le critère de proximité}

$T$ $\gets \emptyset$\;

$tree$ $\gets$ \texttt{STRtree($V$)}\;

\ForEach{$u$ $\in$ $V$}{
    $neighbours$ $\gets$ $tree$.query($u$, $x$)\;
    \ForEach{$v$ $\in$ $neighbours$}{
        $weight$ $\gets$ walktime($u$, $v$)\;
        $T$.add(Edge($u$, $v$, $weight$))\;
    }
}
\Return $T$\;
\end{algorithm}

L'algorithme \ref{algo:footbt} construit $T$ à l'aide d'un arbre STR. La complexité de celui-ci est en moyenne en
$O(|V|\bar{t}_{x} + |V|log|V|)$ et dans le pire cas en $O(|V|^{2})$. Cette alternative est beaucoup plus efficace que l'approche naïve.

\vspace{2pt}
\textbf{Estimation du temps de marche}
\vspace{2pt}

Nous avons donc la distance à vol d'oiseau entre deux gares. Mais comment pouvons-nous déterminer la distance à pied ? Les humains n'ont pas été conçu pour traversé les murs. Certains obstacles sur le chemin doivent être contourné. Dans les entrées du problème nous avons seulement accès aux coordonnées géographiques des gares. Nous estimons donc la distance réelle $w_{(u, v)}$ entre deux gares $u$ et $v$ à partir de la distance à vol d'oiseau $d_{(u, v)}$:
\[
w_{(u, v)} = \frac{\pi}{2} \times d_{(u, v)}
\]
Cette formule vient du mouvement naturel de contournement d'un obstacle: un arc de cerlce autour de celui-ci:

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
    \coordinate (u) at (0, 0);
    \coordinate (v) at (4, 0);
    \draw (u) arc[start angle=180, end angle=0, radius=2];
    \fill (u) circle (2pt) node[below] {$u$};
    \fill (v) circle (2pt) node[below] {$v$};
    \node at (2, -0.5) {$d_{(u, v)}$};
    \node at (2, 2.2) {$w_{(u, v)}$};
    \draw[dashed] (u) -- (v);
    \end{tikzpicture}
    \caption{Représentation d'un contournement d'obstacle à pied}
    \label{fig:walkdist}
\end{figure}

Cette distance semble donc être une bonne norme maximale qui estime l'impact qu'a un obstacle sur le trajet à pied d'un utilisateur.

La vitesse moyenne à pied ($human\_speed$) est de 5km/h \cite{Ralston1958}. Nous comptons également 90 secondes de marche de sécurité ($safety\_padding$) pour descendre et monter des transports. Pour obtenir le poid des arcs de transfert, nous appliquons la formule:
\newline
\newline
$t_{(u,v)} = w_{(u, v)} \times human\_speed + safety\_padding$

\subsection*{Comment l'algorithme fonctionne}
\label{explication_TD}

L'algorithme qui cherche le meilleur chemin est, comme dit plus haut, une variante de TD-Dijkstra. Il peut exister plusieurs n\oe uds sources et plusieurs n\oe uds cibles. Nous retournerons le meilleur chemin du noeud $u$ à $v$ où $u$.name = $s$ et $v$.name = $t$.

Dans les pseudocodes de cette section, nous stockons le coût, l'heure d'arrivée et le dernier arc du meilleur chemin jusque $v$ dans $v$.best\_cost, $v$.best\_time et $v$.best\_edge.

\begin{algorithm}
\caption{TD-Dijkstra}
\label{algo:tddij}
\label{algo:td-dijkstra}
\KwIn{$G$ : un graphe, $s$ : nom de la source, $t$ : nom de la cible, $h$: heure de départ}
\KwOut{le chemin le moins coûteux de $s$ à $t$ dès $h$}

$heap$ $\gets \emptyset$\;
\ForEach{$u$ $\in$ $V$}{
    \If{$u$.name = $s$}{
        $u$.best\_cost $\gets (0, 0)$\;
        $heap$.insert($u$, $(0, 0)$)\;
    }
    \Else{
        $u$.best\_cost $\gets (\infty, \infty)$\;
        $heap$.insert($u$, $(\infty, \infty)$)\;
    }
}

\While{$heap$.size > 0}{
    $u \gets heap$.delMin()\;
    \If{$u$.name = $t$}{
        \Return reconstruct\_solution($u$)\;
    }
    \ElseIf{$u$.cost = $\infty$} {
        \Return $\emptyset$\;
    }
    relaxe($u$, $heap$)\;
}
\end{algorithm}

La raison pour laquelle les coûts sont des couples d'entier et la fonction de coût sont expliquées dans la sous-section "Variantes" plus bas.
\newline
\newline
Dans l'algorithme TD-Dijkstra \ref{algo:tddij} (qui n'est qu'une pâle copie de l'algorithme de Dijkstra), nous initialisons un tas binaire avec $(\infty, \infty)$ pour tous les n\oe uds sauf les n\oe uds sources qui sont initialisés à $(0, 0)$ (le poids du chemin d'un n\oe ud à lui-même est par définition nul). Le but est de piocher dans le tas (heap.delMin) chaque n\oe ud qui a son chemin de coût minimal et pour celui-ci, nous vérifions s'il n'est pas la cible ou de coût égale à $(\infty, \infty)$. Si un n\oe ud pioché est la cible: nous venons de trouver le chemin au moindre coût de la source jusqu'à la cible (principe de Dijkstra one-to-one). Si le chemin d'un n\oe ud a un coût infini, nous ne trouverons plus de meilleurs chemins dans les prochaine pioche et pouvons donc arrêter l'algorithme. Pour chaque n\oe ud pioché, nous améliorons le coût de tout les voisins (Relaxation).

\subsubsection*{Relaxation}

\begin{algorithm}
\caption{Relaxation}
\label{algo:relaxe}
\label{algo:td-dijkstra}
\SetKwProg{Fn}{Routine}{}{}
\Fn{relaxe($v$, $heap$)}{
\ForEach{$e$ arc sortant de $v$}{
    $candidate \gets$ function\_cost($v$, $e$)\;
    \If{$candidate$ < $e$.to.best\_cost}{
        $e$.to.best\_cost $\gets candidate$\;
        $e$.to.best\_edge $\gets e$\;
        $e$.to.best\_time $\gets v.\text{best\_time} + W_{v, e} + e.duration$\;
        $heap$.decreaseKey($e$.to, $candidate$)\;
    }   
}
}
\end{algorithm}

La relaxation d'un n\oe ud $u$ évalue le coût avec la fonction de coût sur chaque voisin (par transfert et par connexion). Pour rappel, vu qu'on considère le temps d'attente positif dans sa définition, tous les voisins doivent être traité, même ceux dont l'heure de départ de la connexion part avant l'heure d'arrivée du chemin jusque $u$. Si, pour un voisin $v$, nous trouvons un meilleur chemin passant par $u$, nous mettons à jour $v$.best\_cost, $v$.best\_time et $v$.best\_edge et la position de $v$ dans le tas (heap.decreaseKey) grâce au meilleur chemin menant jusque $u$.

\subsubsection*{Reconstruction de la solution}

\begin{algorithm}
\caption{Reconstruction du chemin}
\label{algo:td-dijkstra}
\SetKwProg{Fn}{Routine}{}{}
\Fn{reconstruct\_solution($s$, $v$)}{
$path \gets \emptyset$\;

$current \gets t.$best\_predecessor\;
\While{$\exists current$}{
    $path$.add($current$)\;
    if ($current$.from = $s$) {
        \textbf{break}\;
    }
    $current \gets current.$from.best\_predecessor\;
}
\Return $path$
}
\end{algorithm}

Une fois qu'un n\oe ud cible a été pioché du tas, nous devons reconstruire le chemin de $s$ à $t$. Nous effectuons un parcour de la liste chainée formée par les prédécesseurs stockés dans $v$.best\_edge depuis la cible jusqu'à atteindre la première source rencontrée sur le chemin.

\subsection*{Pourquoi l'algorithme fonctionne}

La démonstration de correction ci-dessous est issue directement du syllabus INFOF203 24-25 de l'Université libre de Bruxelles \cite{cardinal2025}.

\begin{lemma}
    L'algorithme de TD-Dijkstra de $s$ à $t$ dès $h$ dans le graphe temporel $G(V, A, T)$ retourne le chemin $P$ qui minimise le coût (défini par la fonction de coût) parmi tous les chemins valides de $s$ à $t$.
\end{lemma}

\begin{proof}[Démonstration par l'absurde]
    $ $\newline
    \newline
    Si $P$ est le chemin minimisant le coût, $t$.best\_cost, il minimise également $v$.best\_cost pour tout $v$ le composant.
    \newline
    \newline
    Vu que TD-Dijkstra retourne le chemin obtenu dès que $t$ est pioché du tas, nous devons prouvé que pour tout $u$ pioché après un n\oe ud $v$ du tas, $u$.best\_cost $\geq$ $v$.best\_cost.
    \newline
    \newline
    Supposons que ce n'est pas le cas: un n\oe ud $u$ pioché après un n\oe ud $v$ a un chemin moins coûteux que $v$.
    \newline
    \newline
    Cela indique qu'il y a eu une relaxation avant que $u$ soit pioché qui améliore son coût à $u$.best\_cost $<$ $v$.best\_cost.
    \newline
    \newline
    Deux cas possibles:
    \begin{enumerate}[leftmargin=1.5em, itemsep=0.5em]
        \item Cette relaxation à lieu \textbf{avant} que $v$ soit pioché: Cela voudrait dire qu'au moment de pioché $v$, $u$.best\_cost $<$ $v$.best\_cost et que donc ce serait $u$ qui devrait être pioché avant $v$. \textcolor{red}{contradiction}
        \item Cette relaxation à lieu \textbf{après que ou lorsque} $v$ soit pioché : Deux cas s'offrent à nouveau à nous (avec $w$ le n\oe ud de la relaxation):
        \begin{enumerate}[leftmargin=1.5em, itemsep=0.5em]
          \item Si $w$.best\_cost $<$ $v$.best\_cost, nous revenons au cas de base (où au lieu de parler de $u$, nous parlons de $w$).
        
          \item Si $w$.best\_cost $\geq$ $v$.best\_cost, par le lemme \ref{lemma:poscost},
          la fonction de coût utilisée par notre algorithme de TD-Dijkstra lors de la relaxation d'un n\oe ud $w$ ne peut être inférieur à $w$.best\_cost (et donc pour $v$ et tous les n\oe uds  piochés après, il est impossible d'améliorer $u$.best\_cost en dessous de $v$.best\_cost. \textcolor{red}{contradiction} 
        \end{enumerate}
    \end{enumerate}
\end{proof}

\subsection*{Variantes du problème}
\label{var}

\begin{algorithm}
\caption{Fonction de coût}
\label{algo:td-dijkstra}
\SetKwProg{Fn}{Routine}{}{}
\Fn{cost\_function($v$, $e$)}{
$d_{v+e} \gets v\text{.best\_time} + W_{(v, e)} + e.\text{duration} \times weight_{e.type}$\;
\If{$e$.trip != $v$.best\_edge.trip}{
    $n_{v+e} \gets n_P + 1$\;
}
\Else{
    $n_{v+e} \gets n_P$\;
}

\If{$priority = TIME$}{
    \Return $v$.best\_cost + $(d_{v+e} , n_{v+e})$\;
}
\ElseIf{$priority = TRIPS$}{
    \Return $v$.best\_cost + $(n_{v+e}, d_{v+e})$\;
}}
\end{algorithm}

Nous avons travaillé sur la généricité de l'algorithme afin d'offrir à l'utilisateur certains paramètres de préférence. La fonction de coût de chemin évalue la durée totale pondérée par mode de transport du chemin et le nombre des changements de trajet.

\begin{definition}[Durée ponderée d'un arc]
    La durée ponderée d'un arc est la durée de celui-ci multiplié par $weight_{e.type}$, une valeur strictement positive choisie par l'utilisateur en fonction de ses préférences de mode de transport:
    \[
    d_e = e.duration \times weight_{e.type}
    \]
\end{definition}

\begin{definition}[Durée ponderée d'un chemin]
    La durée ponderée d'un chemin et la somme des durées ponderées des arcs constitutifs (avec $v$ la gare de départ d'un arc $e$):
    \[
    d_P = \sum_{\substack{e \in P}} (d_e + W_{(v, e)})
    \]
\end{definition}

\begin{definition}[Nombre de changements de trajet]
    Le nombre de changements de trajet d'un chemin $n_P$ est le nombre de fois où l'utilisateur doit entrer dans un nouveau transport ou entamer une nouvelle marche à pied.
\end{definition}

Dès lors, le coût d'un chemin $P$ que nous cherchons à minimiser vaut:
\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item au tuple ($d_P$, $n_P$) si l'utilisateur veut minimiser en priorité la durée pondérée totale.
    \item au tuple ($n_P$, $d_P$) si l'utilisateur veut minimiser en priorité le nombre de changements de trajet.
\end{itemize}

Nous stockons le coût composé de ces deux critères dans un couple. Comparer deux coût revient à d'abord comparer le premier élément puis le second. Donc le premier critère du couple sera minimisé en priorité. Additioner deux coût revient à additioner les éléments entre eux.

Pour rajouter un arc $e$ au chemin finissant par la gare $v$, nous avons $d_{P+e}$ et $n_{P+e}$:
\[
d_{v+e}= d_v + W_{(v, e)} + d_e
\]
\[
n_{v+e} =
\begin{cases}
n_v & \text{\tiny si $e$.trip = $v$.predecessor.trip}\\
n_v + 1 & \text{\tiny sinon}
\end{cases}
\]

\label{lemma:poscost}
\begin{lemma}
    La fonction de coût cost\_function($v$, $e$) qui calcule le coût du meilleur chemin jusque $v$ + $e$ ne peut être inférieur à $v$.best\_cost.
\end{lemma}

\begin{proof}
    $ $\newline
    \newline
    Selon les formules pour trouver $n_{v+e}$ et $d_{v+e}$ ci-dessus
    \begin{enumerate}[leftmargin=1.5em, itemsep=0.5em]
        \item $n_{v+e}$ ne peut être inférieur à $n_v$.
        \item $d_{v+e}$ ne peut être inférieur à $d_v$ car une durée et le temps d'attente ne peuvent être négatif.
    \end{enumerate}
\end{proof}

\subsection*{Exemple de la TOC}

Revenons à notre exemple sur le graphe de la TOC \ref{fig:toc-graph}.
\newline
\newline
Premierement, nous initialisons le tas binaire sachant que $s = $ "Québec" et que le coût est ($d_P$, $n_P$) (donc on prioritise la durée totale du chemin):
\newline
\newline
heap =
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
    \multicolumn{1}{l}{\footnotesize Québec} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (0, 0) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

(Notez que *: ($\infty$, $\infty$) signifie que le reste des gares du tas ont un poids infini)


\textbf{\#1 N\oe ud pioché: } Québec\\
relaxation de ses voisins: Toronto Nord et Ottawa Sud
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Toronto Nord} & 
    \multicolumn{1}{l}{\footnotesize Ottawa Sud} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (45min, 1) & (60min, 1) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}


\textbf{\#2 N\oe ud pioché: } Toronto Nord\\
relaxation de ses voisins: Toronto Sud
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Toronto Sud} & 
    \multicolumn{1}{l}{\footnotesize Ottawa Sud} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (51min, 2) & (60min, 1) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

\textbf{\#3 N\oe ud pioché: } Toronto Sud\\
relaxation de ses voisins: Toronto Nord et Calgary
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Ottawa Sud} & 
    \multicolumn{1}{l}{\footnotesize Calgary} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (60min, 1) & (180min, 3) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

\textbf{\#4 N\oe ud pioché: } Ottawa Sud\\
relaxation de ses voisins: Ottawa Nord
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Ottawa Nord} & 
    \multicolumn{1}{l}{\footnotesize Calgary} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (62min, 2) & (180min, 3) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

\textbf{\#5 N\oe ud pioché: } Ottawa Nord\\
relaxation de ses voisins: Ottawa Sud et Trois-Rivières
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Trois-Rivières} & 
    \multicolumn{1}{l}{\footnotesize Calgary} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (85min, 3) & (180min, 3) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

\textbf{\#6 N\oe ud pioché: } TR (Trois-Rivières)\\
relaxation de ses voisins: Halifax
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Halifax} & 
    \multicolumn{1}{l}{\footnotesize Calgary} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (120min, 3) & (180min, 3) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

\textbf{\#7 N\oe ud pioché: } Halifax\\
relaxation de ses voisins: Montréal
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
    \multicolumn{1}{l}{\footnotesize Montréal} & 
    \multicolumn{1}{l}{\footnotesize Calgary} & 
    \multicolumn{1}{l}{\footnotesize *} \\ 
    \hline
    (165min, 3) & (180min, 3) & ($\infty$, $\infty$)\\ 
    \hline
\end{tabular}
\end{table}

\textbf{\#8 N\oe ud pioché: } Montréal\\
Cible trouvée!
\newline
\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item Durée totale du chemin: 2 heures et 45 minutes (arrivée à 11$:$30$:$00)
    \item Nombre de trajets: 3 (TRAIN A $\rightarrow$ chemin à pied $\rightarrow$ TRAIN B)
\end{itemize}

\section{Implémentation}

Nous avons donnée le nom \texttt{algochoochoo} au projet Java.

\subsection*{Packets Java}

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item \texttt{algochoochoo.cli} lance le CLI
    \item \texttt{algochoochoo.gui} lance la GUI
    \item \texttt{algochoochoo.graph} construit le graphe
    \item \texttt{algochoochoo.query} exécute l'algorithme
    \item \texttt{algochoochoo.parsing} charge et lit les données GTFS
\end{itemize}

\subsection*{Classes principales}

Les classes les plus importantes du programme sont listées ci-dessous. Un descriptif complet est disponible dans la javadoc du projet (voir \texttt{README}) et l'annexe B \ref{annexe:B}.

\begin{itemize}[label=\textbullet, leftmargin=1.5em, itemsep=0.5em]
    \item \texttt{Parser}: Module se chargant de lire les fichiers CSV et de les transformer en tables de trajets (Parser.trips) et de gares (Parser.stops)
    \item \texttt{Node}: Un n\oe ud du graphe qui garde les informations d'une gare lors de l'algorithme de Dijkstra (coût du chemin, etc.)
    \item \texttt{Edge}: Un arc (transfert ou connexion) du graphe avec ses informations (route, trajet, durée, etc.)
    \item \texttt{Graph}: Le graphe $G(V, A, T)$. Construction de $V$ à partir de Parser.stops, de $A$ à partir de Parser.trips et de $T$ à l'aide d'un arbre STR temporaire.
    \item \texttt{Algorithm}: Module d'exécution d'une requête du plus court chemin. Algorithm.dijkstra lance l'algorithme de TD-Dijkstra à l'aide des méthodes Algorithm.relaxe et Algorithm.build\_solution. Le lancement du CLI est contenu dans la méthode main de la classe.
    \item \texttt{cli.View et gui.View}: Modules qui gèrent l'affichage (sur cli ou sur gui) du programme.
    \item \texttt{AlgoSettings}: Stockage des préférences utilisateur sur l'exécution de l'algorithme pour les variances (poids, priorité, etc.). Cette classe est responsable du calcul du coût des chemins (AlgoSettings.cost\_function).
    \item \texttt{GraphSettings}: Stockage des préférences utilisateur sur la construction du graphe (critère de proximité, etc.)
\end{itemize}

\subsubsection*{Chemin de l'information}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[>=stealth, auto]
      \node[rectangle, draw] (lec) at (-1,10) {Lecture GTFS};
      \node[rectangle] (tr) at (-2,8.25) {Map<String, Trip>};
      \node[rectangle] (path) at (-1, 11) {chemin d'accès dossier GTFS};
      \node[rectangle] (st) at (0,8.75) {Map<String, Stop>};
      \node[rectangle, draw, text width = 2cm, align=center] (graph) at (-1, 7) {Construction du graphe};
      \node[rectangle] (V) at (-2,6) {$V$};
      \node[rectangle] (A) at (-1,6) {$A$};
      \node[rectangle] (T) at (0,6) {$T$};
      \node[rectangle] (G) at (-1,5) {$G$};
      \node[rectangle, draw] (query) at (0, 4) {Requête};
      \node[rectangle] (res) at (0, 3) {List<Edge>};
      \node[circle, draw] (user) at (3, 7) {Utilisateur};
      \node[rectangle] (s) at (2, 5.5) {$s$};
      \node[rectangle] (t) at (3, 5.5) {$t$};
      \node[rectangle] (h) at (4, 5.5) {$h$};
      % \node[rectangle, draw] (M) at (8,1) {M};

      \path[->, thick]
        (query) edge (res);
      \path[->, thick]
        (lec) edge[bend right] (tr);
      \path[->, thick]
        (path) edge[bend right] (lec);
      \path[->, thick]
        (lec) edge[bend left] (st);
      \path[->, thick]
        (st) edge (graph);
      \path[->, thick]
        (tr) edge (graph);
      \path[->, thick]
        (graph) edge (V);
      \path[->, thick]
        (graph) edge (A);
      \path[->, thick]
        (graph) edge (T);
      \path[->, thick]
        (T) edge (G);
      \path[->, thick]
        (V) edge (G);
      \path[->, thick]
        (A) edge (G);
      \path[->, thick]
        (G) edge[bend right] (query);
      \path[->, thick]
        (user) edge (h);
      \path[->, thick]
        (user) edge (t);
      \path[->, thick]
        (user) edge (s);
      \path[->, thick]
        (s) edge[bend left] (query);
      \path[->, thick]
        (h) edge[bend left] (query);
      \path[->, thick]
        (t) edge[bend left] (query);
    \end{tikzpicture}
    \caption{Cheminement de l'information dans le programme Java}
    \label{fig:dataflow}
\end{figure}

\subsubsection*{Convertir le contenu de stop\_times.csv en trajets}

L'une des façons les plus optimales de construire la table des trajets reviens à rajouter chaque ligne de stop\_times.csv dans son trajet (sans se préoccuper de la séquence) et ensuite de trier chaque trajet de la table (par \texttt{stop\_sequence}). Ainsi, on obtient les gares consécutives dans les trajets, qui formeront des arcs de connexions dans le graphe $G$.

\subsubsection*{Stockage du coût}

Dans ce rapport, nous définissons le coût comme un couple d'entiers. En java, nous représentons cela par une variable de type \texttt{long} où les 4 premiers octets stocke le premier entier du couple et les 4 suivants le second:

\begin{figure}[H]
    \centering
\noindent
\begin{tabular}{|*{4}{c}|*{4}{c}|}
  \hline
  \multicolumn{4}{|c|}{$n_P$} & \multicolumn{4}{c|}{$d_P$} \\ 
  \hline
  0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ 
  \hline
\end{tabular}
    \caption{Stockage d'un coût $(n_P, d_P)$ d'un chemin en Java}
    \label{fig:bytelist-cost}
\end{figure}

\renewcommand{\refname}{Références}
\section{Analyse de la complexité}

\subsection*{Complexité temporelle}
Pour rappel nous avons déjà mis un nom sur les données suivantes:
\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item $V$ L'ensemble de gares
    \item $A$ L'ensemble de connexions
    \item $T$ L'ensemble de transferts
    \item $x$ Le critère de proximité
    \item $\bar{t}_{x}$ Le nombre moyen de gares dans un rayon de $x$ mètres autour d'une gare
\end{itemize}
Et nous définissons par la même occasion:
\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item $R$ L'ensemble de routes
    \item $F$ L'ensemble de trajets
\end{itemize}
\subsubsection*{Lecture GTFS}
Cette opération revient à parcourir et stocker les gares, routes, trajets et connexions, ainsi que de trier le contenus des trajets:

Parcourir les gares: $O(|V|)$.\\
Parcourir les routes: $O(|R|)$.\\
Parcourir les trajets: $O(|F|)$.\\
Parcourir les connexions: $O(|A|)$.\\
Trier le contenu de $|F|$ trajets qui ont en moyenne une taille de $\frac{|A|}{|F|}$ : $O({|F|} \times \frac{|A|}{|F|} log\frac{|A|}{|F|}) = O({|A|}log\frac{|A|}{|F|})$.\\

En sommant le tout, nous avons:

\[
O(|V| + |R| + |F| + |A|log\frac{|A|}{|F|})
\]

\subsubsection*{Construction du graphe}
Cette opération revient à créer $V$, $T$ et $A$:

Créer les n\oe uds du graphe: $O(|V|)$.\\
Convertir les trajets en connexions: $O(|F| \times \frac{|A|}{|F|}) = O(|A|)$.\\
Évaluer les transferts à l'aide d'un arbre STR (voir \ref{algo:footbt}): $O(|V|\bar{t}_{x}+|V|log|V|)$.\\

Ce qui nous donne:

\[
O(\bar{t}_{x}|V| + |V|log|V| + |A|)
\]

\subsubsection*{Requête}

TD-Dijsktra utilise un tas binaire de taille $|V|$ qui offre les opérations:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item \texttt{heap.insert} en O($log|V|$)
    \item \texttt{heap.delMin} en O($log|V|$)
    \item \texttt{heap.decreaseKey} en O($log|V|$)
\end{itemize}

L'initialisation du tas se fait en $O(|V|log|V|)$ (nous avons consciense qu'il est possible de construire un tas binaire en $O(|V|)$ mais l'implémentation du tas binaire d'algs4 que nous utilisons ne l'offre pas).

Dans le pire des cas, nous vidons l'entiereté du tas binaire (heap.delMin) en $O(|V|log|V|)$ et effectuons une relaxation sur chaque n\oe ud. Une relaxation (avec heap.decreaseKey) sur chaque n\oe ud du graphe implique qu'on visite tous les arcs de celui-ci, donc, en $O((|T| + |A|)log|V|)$.

L'algorithme s'exécute donc en:
\newline
\[
O((|A| + |T| + |V|) log |V|)
\]

dans notre cas car nous utilisons un tas binaire. Nous aurions également pu utiliser un tas de Fibonacci qui réduit la complexité à:

\[
O(|V| log |V| + |A| + |T|)
\]

Nous n'avons pas implémenté de tas de Fibonacci dans notre programme Java du à la complexité et au manque de praticité de la structure.

\subsubsection*{Totale}

L'exécution des 3 étapes ci-dessus se fera en:

\[
O(|R| + |F| + |A|log\frac{|A|}{|F|} + \bar{t}_{x} + (|A| + |T| + |V|) log |V|)
\]

\subsection*{Complexité spatiale}

\subsubsection*{Lecture GTFS}

La lecture qui converti des données GTFS en deux table de hashage: les trajets remplis ($|F|$ trajets stockant les arcs sous forme de tableau) et les gares. 
\newline
\newline
Un trajet de $n$ gares sera converti en $n-1$ arcs dans le graphe, donc $|F|$ trajets stockant en moyenne $n$ gares (tel que $|F|\times(n-1) = |A|$) a une complexité spatiale de $O(|A| - |F|)$.
\newline
\newline
Ce module utilise un arbre STR (qui n'est qu'un arbre R) contenant $|V|$ éléments. 
\newline
\newline
La complexité est donc de $O(|V| + |A| - |F|)$. 

\subsubsection*{Graphe}

Comme dit dans la solution, le graphe est représenté par une liste d'adjacence. La classe Java \texttt{Graph} stocke un tableau de n\oe uds (classe \texttt{Node}) qui eux-mêmes stockent des tableaux pour les arcs de transfert et de connexion sortant. La complexité du graphe est donc:

\[
O(|V| + |A| + |T|)
\]

\subsubsection*{Requête}

La requête se sert d'un tas binaire d'une taille maximale de $|V|$ éléments.

\subsubsection*{Totale}

\[
O(|V| + |A| + |T| - |F|)
\]

\subsection*{Comparaison avec d'autres algorithmes}

Dans cette section, nous répondons à la grande question: "Dijkstra est-il le bon algorithme à utiliser dans ce contexte ?" (même s'il n'y a pas réellement de bon ou de mauvais algorithme) en comparant celui-ci avec d'autres algorithmes de \textit{Time Depandent Shortest Path} connus.

\subsubsection*{Connection Scan Algorithm}

Le \textit{Connection scan algorithm} (CSA) \cite{csa} est un algorithme de recherche du plus cours chemin dans un graphe dépendant du temps qui se base sur une représentation du graphe par une liste triée des connexions triées par heure de départ et qui prône une recherche en temps linéaire. Nous n'avons pas décidé de travailler avec par manque de généricité de l'algorithme (très difficile d'y inclure d'autres fonctions de coût que le temps total du chemin) et à cause des chemins à pied. En effet, implémenter les transferts dans le CSA correctement demande de nombreuses connaissances et algorithmes qui dépassent le cadre de ce projet. Une implémentation naïve du CSA auquelle nous avons réfléchi viendrait à relaxer les transferts lors d'une étape de l'itération des connexions si celle-ci améliore le coût pour atteindre un n\oe ud. Or, les graphes issus des données GTFS sont des multigraphes (donc le nombre de connexions peut s'avérer bien plus grand que le nombre de n\oe uds), et avec une relaxation des transferts pour chaque étape de l'itération, la complexité temporelle d'une recherche s'estimerait en $O(|A| \bar{t}_{x})$, ce qui semble peut enviable pour ce type de graphe et/ou un critère de proximité élevé.

\subsubsection*{Bellman-Ford}

L'algorithme de \textit{Bellman-Ford} \cite{bellman1958routing, ford1956network} n'est pas adéquat pour ce contexte car ici le poids des arcs sont positifs (donc pas besoin de gérer les cycles absorbant) et la complexité de la recherche dans le pire des cas est en $O(|V|(|A| + |T|))$.

\subsubsection*{A*}

L'algorithme \textit{A*} \cite{4082128} est une amélioration directe de l'algorithme de Dijkstra one-to-one à l'aide d'une heuristique pour diriger le dévloppement vers le n\oe ud cible afin de visiter le moins de n\oe uds possible. Il est essentiel pour l'admissibilité de A* que l'heuristique soit elle-même admissible (c'est-à-dire qu'elle surestime toujours le véritable coût pour se rendre au n\oe ud cible). Trouver et calculer une heurisitque admissible assez intéressante pour gagner en temps d'exécution sur Dijkstra n'est pas une tâche facile, mais nous gardons en tête cet algorithme s'il nous vient un jour l'occasion d'améliorer le contenu de ce projet.

\section{Librairies externes utilisées}

Un guide d'installation est présent dans le fichier \texttt{README}. Ce projet Java utilise le gestionnaire de projet \href{https://maven.apache.org/}{Maven} afin de faciliter l'utilisation des librairies externes et d'éviter les problèmes de portabilités. Nous comptons comme librairies externes:

\begin{itemize}[label=--, leftmargin=1.5em, itemsep=0.5em]
    \item \textbf{univocity-parsers} offrant des outils de parcour de fichiers CSV rapides.
    \item \textbf{algs4} offrant l'implémentation du tas binaire (\texttt{IndexMinPQ}) utilisée pour l'algorithme de TD-Dijkstra.
\end{itemize}

\section{Conclusion}

Plusieurs défis ont été relever dans ce projet. Il fallait correctement analyser les données GTFS et stocker celles-ci dans un graphe $G$ qui offre une bonne complexité spatiale et temporelle pour les requête de plus court chemin. Nous avons également réfléchi sur la façon la plus optimale d'évaluer les chemins à pieds entre les gares, comment les considérer dans l'algorithme de Dijkstra. La généricité de l'algorithme était aussi un autre point important, laissant à l'utilisateur des options pour définir ses préférences de mode de transport et de distance de marche à pied. La théorie des graphes et de recherche du plus court chemin reste un domaine en évolution constante, d'autre algorithme récent (comme CSA, 2017) ou moins ont été consideré dans l'étape de pensée du projet, mais c'est l'algorithme de Dijkstra qui est resorti comme l'un des meilleurs pour le contexte du problème.

\newpage
\bibliography{references}
\newpage
$ $
\newpage
\appendix
\section{Algorithme STR et arbre T}
\label{annexe:A}

Nous utilisons l'implémentation de l'arbre STR de la \texttt{Java Suite Topology}. Sachant que nous ne l'avons pas écrit nous-même en Java, il est important d'en expliquer l'implémentation interne.

\subsection{Algorithme STR}

L'algorithme STR \cite{inproceedings97} est utilisé pour construire efficacement l'arbre R qui partitionne les gares sur le plan (à deux dimensions). Dans notre implémentation on défini $M = 10$ le nombre de gares par feuille. Les grandes étapes sont:

\begin{itemize}[label=\textbullet, leftmargin=1.5em, itemsep=0.5em]
    \item Calcul du nombre de feuilles de l'arbre: $l = |V|/M = |V|/10$.
    \item Tri des gares par rapport à la latitude.
    \item Découper le plan en $S$ tranches verticales: $S=⌈\sqrt{\frac{r}{n}}⌉$.
    
\end{itemize}

\subsection{Construction de l'arbre R}

Un arbre R est une amélioration de l'arbre B en 2D qui accelère les requêtes d'intersection. Il collectionne un ensemble de $r$ rectangles dans le plan (2D) qui englobe chacun un maximum de $m$ entrées. Une entrée est caractérisée par un rectangle $R$ et $P$, une gare si c'est une feuille, sinon un n\oe ud fils. Le rectangle $R$ d'un n\oe ud de l'arbre est le MBR (Minimum bounding rectangle) du sous-arbre du n\oe ud (C'est-à-dire le plus petit rectangle englobant la gare si c'est une feuille ou toutes les gares de toutes les feuilles du sous-arbre sinon).

\subsection{Requête sur l'arbre R}

Une requête brute sur l'arbre R demande toutes les gares dans un rectangle $Q$. Lors de celle-ci, nous devons parcourir tout les rectangles qui intersectionne $Q$. Cela revient simplement à effectuer une recherche récursive dans l'arbre en commençant à la racine. Pour chaque n\oe ud que l'on visite:

\begin{itemize}[label=\textbullet, leftmargin=1.5em, itemsep=0.5em]
    \item Le n\oe ud est une feuille: on ajoute la gare $P$ au résultat.
    \item Le n\oe ud est interne: on effectue un appel récursif sur tous les sous-n\oe uds $P$ dont $R$ intersectionne la requète $Q$.
\end{itemize}

Mais, lors de notre algorithme, nous ne recherchons pas les gares dans un rectangles $Q$ mais dans le cercle de rayon $x$ (critère de proximité) autour d'une gare. Pour régler ceci, nous effectuons premièrement une requête rectangulaire et ensuite un filtrage des voisins trouvés qui se trouve bel et bien dans le cercle.

\begin{algorithm}
\caption{Recherche rectangulaire dans l'arbre R}
\label{algo:rectquerytreer}
\SetKwProg{Fn}{Routine}{}{}
\Fn{STRtree.rect\_query($node$, $Q$)}{
    $result \gets \emptyset$\;
    \ForEach{$(R, P) \in node$}{
   \If{$R \cap Q$}{
   \If{$node$.is\_leaf}{
        $result$.add($P$)\;
        }
        \Else{
        $result$.add(STRtree.query($P$, $Q$)\;
        
        }
    }
  }
    \Return $result$\;
}
\end{algorithm}

L'algorithme \ref{algo:rectquerytreer} décrit la recherche récursive des gares dans un rectangle $Q$ dans l'arbre R.

\begin{algorithm}
\caption{Recherche de rayon dans l'arbre R}
\label{algo:radquerytreer}
\SetKwProg{Fn}{Routine}{}{}
\Fn{STRtree.query($u$, $x$)}{
    $result \gets \emptyset$\;
    $rect\_result \gets $ STRtree.rect\_query($root$, [$u_{lon} -x$, $u_{lon} +x$], [$u_{lat} -x$, $u_{lat} +x$])\;
    \ForEach{$v \in result$}{
        \If{dist($v$, $u$) < $x$}{
            $results$.add($v$)\;
        }
    }
    \Return $result$\;
}
\end{algorithm}

L'algorithme \ref{algo:radquerytreer} décrit la recherche dans un rayon de $x$ mètres autour d'une gare $u$. Il construit d'abord un carré autour de $u$ de longueur $2x$ pour effectuer une recherche rectangulaire. Notez que le pseudocode est simplifiée au niveau des distances, qui doivent être adaptée normalement selon la courbure de la terre (avec la formule d'haversine).

Soit un plan avec un certain nombre de gare:

\begin{figure}[H]
    \centering
\begin{tikzpicture}
    % Dessin de la grille
    \draw[step=1cm, gray, very thin] (-3.5, -3.5) grid (3.5, 3.5);

    \fill (-2.7, 1.4) circle (2pt);
    \fill (1.8, -2.2) circle (2pt);
    \fill (0.5, 3.1) circle (2pt);
    \fill (-1.3, -1.8) circle (2pt);
    \fill (2.4, 0.9) circle (2pt);
    \fill (-0.9, 2.7) circle (2pt);
    \fill (3.1, -0.4) circle (2pt);
    \fill (-2.5, -2.8) circle (2pt);
    \fill (0.2, -1.4) circle (2pt);
    \fill (1.1, 2.3) circle (2pt);
    \fill (-1.8, 0.5) circle (2pt);
    \fill (2.6, -1.7) circle (2pt);
    \fill (-0.4, 0.8) circle (2pt);
    \fill (0.9, -3.0) circle (2pt);
    \fill (-3.0, 2.1) circle (2pt);
    \fill (0.7, -0.3) circle (2pt);
    \fill (1.5, 1.7) circle (2pt);
    \fill (-2.1, -1.1) circle (2pt);
    \fill (2.9, -2.6) circle (2pt);
    \fill (-1.7, 3.0) circle (2pt);
    \fill (3.2, 1.0) circle (2pt);
    \fill (-2.8, -0.5) circle (2pt);
    \fill (1.2, -3.2) circle (2pt);
    \fill (-0.6, 1.5) circle (2pt);
    \fill (0.3, -2.7) circle (2pt);
    \fill (-2.3, 0.2) circle (2pt);
    \fill (2.1, 2.5) circle (2pt);
    \fill (-0.2, -1.0) circle (2pt);
    \fill (1.7, -2.4) circle (2pt);
    \fill (-1.4, 1.2) circle (2pt);
    \fill (2.8, -1.3) circle (2pt);
    \fill (-3.3, -0.7) circle (2pt);
    \fill (0.6, 2.8) circle (2pt);
    \fill (-1.9, -2.3) circle (2pt);
    \fill (1.0, 0.5) circle (2pt);
    \fill (-0.8, -3.1) circle (2pt);
    \fill (2.3, 1.3) circle (2pt);
    \fill (-2.9, 2.2) circle (2pt);
    \fill (1.9, -0.6) circle (2pt);
    \fill (-1.5, 3.3) circle (2pt);
    \fill (0.4, -2.1) circle (2pt);
    \fill (-0.5, 0.0) circle (2pt);
    \fill (2.5, -1.5) circle (2pt);
    \fill (-3.2, 1.8) circle (2pt);
    
    % Axes
    % \draw[->, thick] (-4, 0) -- (4, 0) node[right] {$x$};
    % \draw[->, thick] (0, -4) -- (0, 4) node[above] {$y$};

\end{tikzpicture}    
    \caption{Plan d'exemple contenant 45 gares}
    \label{fig:tree-ex1}
\end{figure}

Un partitionnement balancé du plan construit par l'algorithme STR:

\begin{figure}[H]
    \centering

\begin{tikzpicture}
    %--- Grille et points (45 points) ---%
    \draw[step=1cm, gray, very thin] (-3.5, -3.5) grid (3.5, 3.5);


    \fill[pattern=north east lines, pattern color=blue!50]  (0.2, -0.7) rectangle (3.5, 3.4);
    \fill[pattern=north east lines, pattern color=blue!50]  (-0.4, -0.8) rectangle (3.1, -3.4);
    \fill[pattern=north east lines, pattern color=blue!50]  (-3.5, -3.3) rectangle (-0.6, 0.7);

    \fill[pattern=north east lines, pattern color=blue!50]  (-3.4, -0.2) rectangle (-0.2, 3.5);

    \fill[pattern=north east lines, pattern color=red!50]  (-3.3, 2.3) rectangle (-2.6, 1.3);
    \fill[pattern=north east lines, pattern color=red!50]  (-3.4, -0.3) rectangle (-1.7, -1.2);
    \fill[pattern=north east lines, pattern color=red!50]  (-0.3, -0.9) rectangle (0.5, -2.2);
    \fill[pattern=north east lines, pattern color=red!50]  (-2.6, -1.7) rectangle (-1.2, -2.9);
    \fill[pattern=north east lines, pattern color=red!50]  (0.2, -2.6) rectangle (1.3, -3.3);
    \fill[pattern=north east lines, pattern color=red!50]  (-0.9, -3) rectangle (-0.7, -3.2);
    \fill[pattern=north east lines, pattern color=red!50]  (2.4, -1.2) rectangle (3, -2.7);
    \fill[pattern=north east lines, pattern color=red!50]  (1.6, -2.1) rectangle (1.9, -2.5);
    \fill[pattern=north east lines, pattern color=red!50]  (-1.8, 2.6) rectangle (-0.8, 3.4);
    \fill[pattern=north east lines, pattern color=red!50]  (0.3, 3.3) rectangle (3.4, 0.8);
    \fill[pattern=north east lines, pattern color=red!50]  (0.6, 0.6) rectangle (3.2, -0.7);
    \fill[pattern=north east lines, pattern color=red!50]  (-1.5, -0.1) rectangle (-0.3, 1.6);

    \fill[pattern=north east lines, pattern color=red!50]  (-1.7, 0.1) rectangle (-2.4, 0.6);
    % Liste des 45 points
    \foreach \x/\y in {
      -2.7/1.4, 1.8/-2.2, 0.5/3.1, -1.3/-1.8, 2.4/0.9,
      -0.9/2.7, 3.1/-0.4, -2.5/-2.8, 0.2/-1.4, 1.1/2.3,
      -1.8/0.5, 2.6/-1.7, -0.4/0.8, 0.9/-3.0, -3.0/2.1,
      0.7/-0.3, 1.5/1.7, -2.1/-1.1, 2.9/-2.6, -1.7/3.0,
      3.2/1.0, -2.8/-0.5, 1.2/-3.2, -0.6/1.5, 0.3/-2.7,
      -2.3/0.2, 2.1/2.5, -0.2/-1.0, 1.7/-2.4, -1.4/1.2,
      2.8/-1.3, -3.3/-0.7, 0.6/2.8, -1.9/-2.3, 1.0/0.5,
      -0.8/-3.1, 2.3/1.3, -2.9/2.2, 1.9/-0.6, -1.5/3.3,
      0.4/-2.1, -0.5/0.0, 2.5/-1.5, -3.2/1.8
    }{
        \fill[black] (\x,\y) circle (1.8pt); 
    }

    \draw[thick] (-3.3, 2.3) rectangle (-2.6, 1.3);
    \draw[thick] (-3.4, -0.3) rectangle (-1.7, -1.2);
    \draw[thick] (-0.3, -0.9) rectangle (0.5, -2.2);
    \draw[thick] (-2.6, -1.7) rectangle (-1.2, -2.9);
    \draw[thick] (0.2, -2.6) rectangle (1.3, -3.3);
    \draw[thick] (-0.9, -3) rectangle (-0.7, -3.2);
    \draw[thick] (2.4, -1.2) rectangle (3, -2.7);
    \draw[thick] (1.6, -2.1) rectangle (1.9, -2.5);
    \draw[thick] (-1.8, 2.6) rectangle (-0.8, 3.4);
    \draw[thick] (0.3, 3.3) rectangle (3.4, 0.8);
    \draw[thick] (0.6, 0.6) rectangle (3.2, -0.7);
    \draw[thick] (-1.5, -0.1) rectangle (-0.3, 1.6);
    \draw[thick] (-0.4, -0.8) rectangle (3.1, -3.4);
    \draw[thick] (-3.5, -3.3) rectangle (-0.6, 0.7);
    \draw[thick] (-3.4, -0.2) rectangle (-0.2, 3.5);
    \draw[thick] (0.2, -0.7) rectangle (3.5, 3.4);
    \draw[thick] (-1.7, 0.1) rectangle (-2.4, 0.6);

    \node[below=0cm of current bounding box.south] (legend) {
        \begin{tikzpicture}[x=1cm, y=0.6cm]
            \foreach \color/\label/\pos in {blue!50/N\oe ud interne/0, red!50/Feuille/1} {
                \fill[pattern=north east lines, pattern color=\color] (0, \pos) rectangle (0.8, \pos+0.4);
                \draw (0, \pos) rectangle (0.8, \pos+0.4);
                \node[right] at (1.2, \pos+0.2) {\label};
            }
        \end{tikzpicture}
    };
\end{tikzpicture}
    \caption{Partitionnement balancé des 45 gares dans un arbre R}
    \label{fig:tree-ex1}
\end{figure}

\begin{figure}[H]
    \centering
\resizebox{\linewidth}{!}{%
    \begin{tikzpicture}[
  grow=down,
  level distance=1.5cm,
  % Distances différentes selon les niveaux
  level 1/.append style={sibling distance=100pt},   % racine → 4 bleus
  level 2/.append style={sibling distance=20pt},   % bleus → rouges
  level 3/.append style={sibling distance=3pt}, % rouges → cercles
  level 4/.append style={sibling distance=1pt},   % éventail si grow=right
  % pour le niveau 4, on peut aussi faire grandir latéralement
  level 4/.append style={grow=right},
  edge from parent/.style = {draw},
  every node/.style={}
]

% Racine
\node[root]{root}
  child { node[level2]{}
    child { node[level3]{}
      child { node[level4]{} }
      child { node[level4]{} }
      child { node[level4]{} }
      child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} }
      child { node[level4]{} }
      child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} }
      child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} }
      child { node[level4]{} }
      child { node[level4]{} }
      child { node[level4]{} }
    }
  }
  child { node[level2]{}
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} }
      child { node[level4]{} } child { node[level4]{} }
      child { node[level4]{} } child { node[level4]{} }
      child { node[level4]{} } child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} }
      child { node[level4]{} } child { node[level4]{} }
    }
  }
  child { node[level2]{}
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} } child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} } child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} }
      child { node[level4]{} } child { node[level4]{} }
    }
  }
  child { node[level2]{}
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} } child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} } child { node[level4]{} } child { node[level4]{} }
    }
    child { node[level3]{}
      child { node[level4]{} }
    }
  };

\end{tikzpicture}%
}
    \caption{Arbre R de la hiérarichie des rectangles de la figure \ref{fig:tree-ex1}}
    \label{fig:tree-ex2}
\end{figure}

La figure \ref{fig:tree-ex3} montre que la recherche dans un carré autour d'une gare $G$ dans notre plan d'exemple compte 7 résultats, tandis que la figure \ref{fig:tree-ex4} indique que la recherche dans un rayon n'en garde que 6 qui sont autour de $G$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
    %--- Grille et points (45 points) ---%
    \draw[step=1cm, gray, very thin] (-3.5, -3.5) grid (3.5, 3.5);

    \fill[pattern=north east lines, pattern color=magenta!50] (0.7-1.5, -0.3-1.5) rectangle (0.7+1.5, -0.3+1.5);

    % Liste des 45 points
    \foreach \x/\y in {
      -2.7/1.4, 1.8/-2.2, 0.5/3.1, -1.3/-1.8, 2.4/0.9,
      -0.9/2.7, 3.1/-0.4, -2.5/-2.8, 0.2/-1.4, 1.1/2.3,
      -1.8/0.5, 2.6/-1.7, -0.4/0.8, 0.9/-3.0, -3.0/2.1,
      0.7/-0.3, 1.5/1.7, -2.1/-1.1, 2.9/-2.6, -1.7/3.0,
      3.2/1.0, -2.8/-0.5, 1.2/-3.2, -0.6/1.5, 0.3/-2.7,
      -2.3/0.2, 2.1/2.5, -0.2/-1.0, 1.7/-2.4, -1.4/1.2,
      2.8/-1.3, -3.3/-0.7, 0.6/2.8, -1.9/-2.3, 1.0/0.5,
      -0.8/-3.1, 2.3/1.3, -2.9/2.2, 1.9/-0.6, -1.5/3.3,
      0.4/-2.1, -0.5/0.0, 2.5/-1.5, -3.2/1.8
    }{
        \fill[black] (\x,\y) circle (1.8pt); 
    }

    \draw[thick, color=magenta!20] (0.7-1.5, -0.3-1.5) rectangle (0.7+1.5, -0.3+1.5);

    \draw[<->, thick] (0.7-1.5, -0.3+1.5) -- node[above]{$2x$} (0.7+1.5, -0.3+1.5);

     \fill[black] (0.7, -0.3) circle (1.8pt) node[above]{G};

\end{tikzpicture}
    \caption{Recherche rectangulaire autour de $G$}
    \label{fig:tree-ex3}
\end{figure}

\begin{figure}[H]
    \centering
\begin{tikzpicture}
    %--- Grille et points (45 points) ---%
    \draw[step=1cm, gray, very thin] (-3.5, -3.5) grid (3.5, 3.5);



    \fill[pattern=north east lines, pattern color=magenta!30] (0.7-1.5, -0.3-1.5) rectangle (0.7+1.5, -0.3+1.5);

    \draw[color=magenta!20] (0.7-1.5, -0.3-1.5) rectangle (0.7+1.5, -0.3+1.5);

    \node[circle, draw, pattern=north east lines, pattern color=red!60, minimum size=3cm, draw opacity=0.35] at (0.7,-0.3) {};

    % Liste des 45 points
    \foreach \x/\y in {
      -2.7/1.4, 1.8/-2.2, 0.5/3.1, -1.3/-1.8, 2.4/0.9,
      -0.9/2.7, 3.1/-0.4, -2.5/-2.8, 0.2/-1.4, 1.1/2.3,
      -1.8/0.5, 2.6/-1.7, -0.4/0.8, 0.9/-3.0, -3.0/2.1,
      0.7/-0.3, 1.5/1.7, -2.1/-1.1, 2.9/-2.6, -1.7/3.0,
      3.2/1.0, -2.8/-0.5, 1.2/-3.2, -0.6/1.5, 0.3/-2.7,
      -2.3/0.2, 2.1/2.5, -0.2/-1.0, 1.7/-2.4, -1.4/1.2,
      2.8/-1.3, -3.3/-0.7, 0.6/2.8, -1.9/-2.3, 1.0/0.5,
      -0.8/-3.1, 2.3/1.3, -2.9/2.2, 1.9/-0.6, -1.5/3.3,
      0.4/-2.1, -0.5/0.0, 2.5/-1.5, -3.2/1.8
    }{
        \fill[black] (\x,\y) circle (1.8pt); 
    }



    \draw[<->, thick] (0.7, -0.3) -- node[above]{$x$} (0.7+1.5, -0.3);

     \fill[black] (0.7, -0.3) circle (1.8pt) node[above]{G};

\end{tikzpicture}
    \caption{Recherche de rayon $x$ autour de $G$}
    \label{fig:tree-ex4}
\end{figure}

\section{Description complète des classes Java}
\label{annexe:B}

Cette annexe contient la description complête des classes, méthodes et attributs publiques du code Java.

\subsubsection*{graph.GraphSettings}

\begin{lstlisting}[caption=Classe graph.GraphSettings, label=class-graph.graphsettings]
package algochoochoo.graph;

/**
 * Stocke les préférences utilisateur pour
 * la construction du graphe
 */
public class GraphSettings {
  /**
   * Construit un GraphSettings par défaut
   */
  GraphSettings();

  /**
   * Construit un GraphSettings depuis le chemin
   * d'accès du dossier GTFS
   */
  GraphSettings(String gtfs_path);

  /**
   * Construit un GraphSettings depuis les
   * arguments de l'exécutable (CLI)
   */
  GraphSettings(String[] args);

  /**
   * Affiche les paramètres sur STDOUT
   */
  void print();

  /** Le chemin d'accès des données GTFS */
  String GTFS_path = "src/main/resources/GTFS";

  /** Le critère de proximité */
  int foot_radius = 500;
}
\end{lstlisting}

\subsubsection*{graph.Graph}

\begin{lstlisting}[caption=Classe graph.Graph, label=class-graph.graph]
package algochoochoo.graph;

/**
 * Un graphe
 */
public class Graph {
  /**
   * Construit le graphe à partir de
   * paramètres utilisateur
   */
  Graph(GraphSettings set);

  /** Convertit un graphe en String */
  @Override
  String toString();

  /**
   * Reconstruit le graphe à partir de
   * nouveaux paramètres
   */
  void reload(GraphSettings new_settings);

  /**
   * Obtient la cardinalité de
   * l'ensemble d'arcs
   */
  int E_card();

  /**
   * Obtient la cardinalité de
   * l'ensemble d'arcs de transfert
   */
  int T_card();

  /**
   * Obtient la cardinalité de
   * l'ensemble d'arcs de connexion
   */
  int A_card();

  /**
   * Obtient la cardinalité de
   * l'ensemble de n\oe uds
   */
  int V_card();

  /**
   * Obtient la liste d'adjacence du graphe
   */
  List<Node> vertices();

  /**
   * Obtient les paramètres utilisés
   * pour la construction du graphe
   */
  GraphSettings settings();
}
\end{lstlisting}

\subsubsection*{graph.Node}

\begin{lstlisting}[caption=Classe graph.Node, label=class-graph.node]
package algochoochoo.graph;

/**
 * Un n\oe ud du graphe
 */
public class Node {
  /**
   * Construit un n\oe ud vide depuis
   * une gare s
   */
  Node(Stop s);

  /** Convertit un n\oe ud en String */
  @Override
  String toString();

  /** 
   * (TD-Dijkstra) Initialise le n\oe ud
   * pour une nouvelle requete
   * meilleur coût: INF
   * meilleur temps: INF
   * meilleur arc: null
   */
  void init();

  /**
   * Obtient la gare du n\oe ud
   */
  Stop stop();

  /**
   * (TD-Dijkstra) Obtient l'arc menant
   * à ce n\oe ud du meilleur chemin à l'étape
   * actuelle de l'algorithme
   */
  Edge best_edge();

  /**
   * (TD-Dijkstra) Obtient le meilleur coût
   * pour atteindre ce n\oe ud à l'étape actuelle de l'algorithme
   */
  long best_cost();

  /**
   * (TD-Dijkstra) Obtient la meilleure
   * heure d'arrivée pour atteindre ce n\oe ud
   * à l'étape actuelle de l'algorithme
   */
  int best_time();

  /**
   * Obtient les arcs de transferts sortants
   * du n\oe uds
   */
  List<Edge> transfers();

  /**
   * Obtient les arcs de connexions sortants
   * du n\oe uds
   */
  List<Edge> connections();

  /**
   * Obtient l'index du n\oe ud dans
   * la liste des n\oe uds
   * représentant le graphe
   */
  int index();

  /**
   * (TD-Dijkstra) Retourne si le n\oe ud est 
   * source de l'algorithme
   */
  boolean is_source();

  /**
   * (TD-Dijkstra) Retourne si le n\oe ud est
   * cible de l'algorithme
   */
  boolean is_target();

  /**
   * (TD-Dijkstra) Améliore les variables
   * coût, heure d'arrivée et arc du chemin
   * après relaxation dans l'algorithme
   */
  void set_best(long cost, int time, Edge edge);

  /**
   * Défini la liste des transferts sortants
   * du n\oe ud
   */
  void set_transfers(List<Edge> t);

  /**
   * Ajoute une connexion du n\oe ud
   * dans sa liste de connexion sortantes
   */
  void add_connection(Edge c);

  /**
   * Défini l'index du n\oe ud dans la liste
   * de n\oe ud représentant le graphe
   * (Nécessaire pour algs4.IndexMinPQ)
   */
  void set_index(int i);

  /**
   * (TD-Dijkstra) Défini ce n\oe ud comme 
   * source de l'algorithme
   */
  void declare_source();

  /**
   * (TD-Dijkstra) Défini ce n\oe ud comme cible
   * de l'algorithme
   */
  void declare_target();
}
\end{lstlisting}

\subsubsection*{graph.Edge}

\begin{lstlisting}[caption=Classe graph.Edge, label=class-graph.Edge]
package algochoochoo.graph;

/**
 * Un arc du graphe
 */
public class Edge {
  /**
   * Construit un arc de connexion à
   * partir de deux elements de trajet (TripElement)
   * Une map {stop_id:Node} et un trajet (Trip)
   */
  Edge(
      TripElement first, TripElement second, Map<String, Node> V, Trip t);

  /**
   * Construit un arc de transfert à partir de deux
   * gares et d'une distance à vol d'oiseau
   */
  Edge(Node source, Node target, int distance);

  /**
   * Construit un arc de dest purement à but
   * de comparaison
   */ 
  Edge(int departure);

  /** Convertit l'arc en String */
  @Override
  String toString();

  /**
   * Obtient une directive en anglais de l'arc
   * Ex: Taking BUS 71
   * (fonctionnalité CLI)
   */
  String directive();

  /**
   * Obtient la gare d'arrivée de l'arc
   */
  Node to();

  /**
   * Obtient la gare de départ de l'arc
   */
  Node from();

  /** 
   * Get the trip of the edge or null if its a transfer
   * 
   * @return Edge trip or null if is transfer
   */
  Trip trip();

  /**
   * Obtient le type de route de l'arc
   */
  RouteType type();

  /**
   * Obtient l'heure de départ de l'arc
   * si c'est un arc de connexion, sinon -1
   */
  int departure_time();

  /**
   * Obtient la durée de l'arc
   */
  int duration();

  /**
   * Retourne si l'arc représente
   * un transfert à pied
   */
  boolean is_transfer();
  /**
   * Retourne si l'arc représente une
   * connexion
   */
  boolean is_connection();

  /**
   * Obtient la couleur de l'arc (fonctionnalité GUI)
   */
  Color color();
}
\end{lstlisting}

\subsubsection*{query.AlgoPriority}

\begin{lstlisting}[caption=Classe query.AlgoPriority, label=class-query.algopriority]
package algochoochoo.query;

/**
 * La priorité de l'algorithme
 * (= critère à minimiser)
 */
public enum AlgoPriority {
  /** La durée totale (pondérée) du chemin */
  TOTAL_DURATION,

  /** Le nombre de changements de trajet */
  TRIP_CHANGES,
}
\end{lstlisting}

\subsubsection*{query.AlgoSettings}

\begin{lstlisting}[caption=Classe query.AlgoSettings, label=class-query.algosettings]
package algochoochoo.query;

/**
 * Stocke les préférences utilisateurs
 * liées à l'exécution de l'algorithme
 */
public class AlgoSettings {
  /**
   * Construit des paramètres par défaut
   */
  AlgoSettings();

  /**
   * Construit les paramètres de l'algorithme à
   * partir des arguments de l'exécutable
   */
  AlgoSettings(String[] args);

  /** 
   * Si le nom des gares sources et cibles doit être identique au 
   * caractère près
   */
  boolean strict_search = true;

  /** Les poids de mode de transport de l'algorithme */
  Map<RouteType, Double> weights = new LinkedHashMap<>();

  /** La priorité de l'algorithme */
  AlgoPriority priority = AlgoPriority.TOTAL_DURATION;

  /**
   * 
   */
  long cost_function(Node v, Edge e);

  /**
   * Affiche les paramètres sur STDOUT
   */
  void print();
}
\end{lstlisting}


\subsubsection*{query.Algorithm}

\begin{lstlisting}[caption=Classe query.Algorithm, label=class-query.algorithm]
package algochoochoo.query;

/**
 * Exécute l'algorithme du plus court chemin
 */
public class Algorithm {
  /**
   * Lance le CLI
   */
  public static void main(String[] args);

  /**
   * Construit un Algorithm avec un graph et des
   * préférences utilisateur
   */
  public Algorithm(Graph G, AlgoSettings set);

  // #### Private helpers ####

  /**
   * Retourne le meilleur chemin de s à t à partir de h
   * en exécutant TD-Dijkstra
   */
  public AlgoResult dijkstra(String s, String t, int h);
}
\end{lstlisting}

\subsubsection*{query.AlgoResult}

\begin{lstlisting}[caption=Classe query.AlgoResult, label=class-query.algoresult]
package algochoochoo.query;

/**
 * Stocke le résultat d'un algorithme de recherche
 * du plus court chemin
 */
public class AlgoResult {

  /** Plus court chemin trouvé */
  List<Edge> path = new ArrayList<>();

  /** Nombre de noeuds visités par Dijkstra */
  int visited_vertices = 0;

  /** Temps de la requête */
  double runtime = 0;

  /** Temps de lecture GTFS et construction du graphe */
  double preruntime = 0;
}
\end{lstlisting}

\subsubsection*{cli.View}

\begin{lstlisting}[caption=Classe cli.View, label=class-cli.view]
package algochoochoo.cli;

/**
 * Gére l'affichage du CLI (command line
 * interface)
 */
public class View {
  /**
   * Affiche dans le terminal un résultat de 
   * l'algorithme (chemin, heure de départ)
   */
  static void print(AlgoResult, int h);
}
\end{lstlisting}

\subsubsection*{gui.View}

\begin{lstlisting}[caption=Classe gui.View, label=class-gui.view]
package algochoochoo.gui;

/**
 * Gére l'affichage du GUI (graphical
 * user interface)
 */
public class View {
  /**
   * Initialise et lance le GUI
   */
  static void main(String[] args);

  /**
   * Construit un GUI
   */
  View();

  /**
   * Initialise le GUI
   */
  void set_up();

  /**
   * Lance le GUI
   */
  void run();
}
\end{lstlisting}

\subsubsection*{gui.PathPainter}

\begin{lstlisting}[caption=Classe gui.PathPainter, label=class-gui.pathpainter]
package algochoochoo.gui;


/**
 * Enfant de la classe Painter<JXMapViewer>
 * de la dépendance JXMapViewer2,
 * Gére le dessin d'un chemin sur la GUI
 */
public class PathPainter implements Painter<JXMapViewer> {
  /**
   * Construit un PathPainter vide
   */
  PathPainter();

  /**
   * Construit un PathPainter avec
   * t les positions des gares
   * c Les couleurs des arcs 
   * w Si les arcs sont des transferts
   */
  PathPainter(List<GeoPosition> t, List<Color> c, List<Boolean> w);

  @Override
  /**
   * Dessine le chemin sur le widget de
   * JXMapViewer
   */
  void paint(Graphics2D g, JXMapViewer map, int w, int h);
}
\end{lstlisting}

\subsubsection*{gui.StopWaypoint}

\begin{lstlisting}[caption=Classe gui.StopWaypoint, label=class-gui.stopwaypoint]
package algochoochoo.gui;

/**
 * Enfant de la class Waypoint
 * de la dépendance JXMapViewer2,
 * Représente une gare sur la carte du GUI
 */
public class StopWaypoint implements Waypoint {
  /**
   * Construit un StopWaypoint avec une position,
   * couleur et si c'est une intersection
   */
  StopWaypoint(GeoPosition pos, Color c, boolean intersec);

  @Override
  /**
   * Obtient la position du Waypoint
   */
  GeoPosition getPosition();

  /**
   * Obtient la couleur du Waypoint
   */
  Color color();

  /**
   * Retourne vrai si le Waypoint est une intersection entre deux trajets
   */
  boolean is_intersection();
}
\end{lstlisting}

\subsubsection*{gui.StopWaypointRenderer}

\begin{lstlisting}[caption=Classe gui.StopWaypointRenderer, label=class-gui.stopwaypointrenderer]
package algochoochoo.gui;

/**
 * Enfant de la classe 
 * WaypointRenderer<Waypoint>
 * de la dépendance JXMapViewer2,
 * Gére l'affichage des gares sur
 * la GUI
 */
public class StopWaypointRenderer
    implements WaypointRenderer<StopWaypoint> {
  /** 
   * Construit un StopWaypointRenderer
   */
  StopWaypointRenderer();

  @Override
  /**
   * Dessine une gare sur la carte
   */
  void paintWaypoint(Graphics2D g, JXMapViewer map, StopWaypoint waypoint);
}
\end{lstlisting}

\end{document}
