# Runtime tests and upgrades

## Current performances of the program

For now on a desktop with high 
- CPU: AMD Ryzen 7 7700 (16) @ 5.39 GHz
- RAM: 32 GB 6000 MHz
- DISK: SSD nvme

We get around 7.82 seconds to build the graph and 0.41 seconds to query a solution in the Belgium public transport network (70.000 nodes, 17.500.000 edges).

I would like to reduce the construction of the graph to less than 5 seconds. Let's see what optimizations are possible in the Java code to reach that utopia.

## Detailed runtime analysis

After debugging the construction of the graph, we get interseting values:

  Parsing stops in 0.048773196 seconds
  Parsing trips in 6.513986 seconds
  Building tree in 0.33130074 seconds
  Creating nodes in 0.009390905 seconds
  Creating connection in 0.6471483 seconds
  Creating transfers in 0.432896 seconds

Which means that the slowest operation is the trips parsing, followed by the BallTree building. These results look logical since the trips parsing is an heavy operation reading files containing milions of lines and sorting those lines. The file parsing is handled by univocity, so we won't touch that part (it's already a really fast option). Let's take a look at the trip planning:

  Creating routes in 0.007507843 seconds
  Creating trips in 0.16031764 seconds
  Populating trips in 5.804175 seconds
  Sorting connections in 0.49444726 seconds

Populating trips is a suboperation of the parsing that read all stop_times.csv file and insert all the times into their corresponding trips. This operation takes 82% of the graph construction runtime. Is there something we did wrong ?

## Tweaking trips population

First, I am going to remove the object construction in the parsing loop:

```java
String csv_file = file + "/stop_times.csv";
for (RStopTime stop_time : iterate(csv_file, RStopTime::new)) {
  // DO NOTHING!
  // TripElement element = new TripElement(stop_time, stops);
  // trips.get(stop_time.trip_id()).add(element);
}
```
The result allows us to conclude that 1/3 of the operation is used to read the files, and the 2/3 to construct objects:

  Populating trips in 2.127125 seconds

Charging the csv files in the memory doesn't help.

But, after ensuring a size of 50 for the trip content, we get a 0.6s average faster operation.

So for now, we are at 7.1 seconds.

